// =====================================================================================
// Copyright (c) 2016, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// libcea2045 ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// #########################################################################################
// Boost Software License, Version 1.0
// #########################################################################################
//
// * catch++ v1.2.1 (https://github.com/philsquared/Catch)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// #########################################################################################
// MIT Licence
// #########################################################################################
//
// * easylogging++ Copyright (c) 2017 muflihun.com
//   https://github.com/easylogging/easyloggingpp
//   https://easylogging.muflihun.com
//   https://muflihun.com
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
/*
 * UniversalControlModule.cpp
 *
 *  Created on: Aug 26, 2015
 *      Author: dupes
 */

#include <iostream>
#include <chrono>
#include <cea2045/util/MSTimer.h>
#include "include/UniversalControlModule.h"

UniversalControlModule::UniversalControlModule () {
	SGD_MAX_PAYLOAD_ = cea2045::MaxPayloadLengthCode::LENGTH2;
}  // end Constructor


UniversalControlModule::~UniversalControlModule () {
}  // end Destructor

std::vector <CommodityData> UniversalControlModule::GetCommodityData () {
	return commodities_;
}  // end Get Commodity Data

unsigned int UniversalControlModule::GetOpState () {
	return op_state_;
}  // end Get Op State

// Is Message Type Supported
// - ...not sure where this is called or where it passes value to?
bool UniversalControlModule::isMessageTypeSupported (
	cea2045::MessageTypeCode messageType) {
	if (messageType == cea2045::MessageTypeCode::NONE) {
		return false;
	} else {
		return true;
	}
}  // end Is Message Type Supported

// Get Max Payload
// - this should just be implemented within the constructor, but I can't change
// - it because it is a pure virtual function of IUCM.
cea2045::MaxPayloadLengthCode UniversalControlModule::getMaxPayload () {
	return cea2045::MaxPayloadLengthCode::LENGTH4096;
}  // end Get Max Payload

// Process Max Payload Response
// - the actual maximum payload by the smart grid device
void UniversalControlModule::processMaxPayloadResponse (
	cea2045::MaxPayloadLengthCode maxPayload) {
	SGD_MAX_PAYLOAD_ = maxPayload;
}  // end Process Max Payload Response

// Process Device Info Response
// - static information about the smart grid device. There is more available to 
// - get, but it doesn't appear to be very helpful at this time.
// TODO(TS): add map to convert type and id.
void UniversalControlModule::processDeviceInfoResponse (
	cea2045::cea2045DeviceInfoResponse* message) {
	device_type_ = (unsigned int)message->getDeviceType ();
	vendor_id_ = (unsigned int)message->getVendorID ();
}  // end Process Device Info Response

// Process Commodity Response
// - store each commodity response in the CommodityData structure and then 
// - store in a vector for parsing.
void UniversalControlModule::processCommodityResponse (
	cea2045::cea2045CommodityResponse* message) {
	int count = message->getCommodityDataCount();

	commodities_.clear ();
	commodities_.reserve (count);
	for (int x = 0; x < count; x++) {
		cea2045::cea2045CommodityData *data = message->getCommodityData (x);
		CommodityData CD;
		CD.code = data->commodityCode;
		CD.cumulative = data->getCumulativeAmount ();
		CD.rate = data->getInstantaneousRate ();
		commodities_.emplace_back (CD);
	}
}  // end Process Commodity Response

// Process Set Energy Price Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processSetEnergyPriceResponse (
	cea2045::cea2045IntermediateResponse *message) {
	// do nothing
}  // end Process Set Energy Price Response

// Process Set Temperature Offset Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processSetTemperatureOffsetResponse (
	cea2045::cea2045IntermediateResponse *message) {
	// do nothing
}  // end Process Set Temperature Offset Response

// Process Get Temperature Offset Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processGetTemperatureOffsetResponse (
	cea2045::cea2045GetTemperateOffsetResponse *message) {
	// do nothing
}  // end Process Get Temperature Offset Response

// Process Set Setpoints Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processSetSetpointsResponse (
	cea2045::cea2045IntermediateResponse *message) {
	// do nothing
}  // end Process Set Setpoints Response

// Process Get Setpoints Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processGetSetpointsResponse (
	cea2045::cea2045GetSetpointsResponse1 *message) {
	// do nothing
}  // end Process Get Setpoints Response

// Process Get Setpoints Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processGetSetpointsResponse (
	cea2045::cea2045GetSetpointsResponse2 *message) {
	// do nothing
}  // end Process Get Setpoints Response

// Process Start Cycling Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processStartCyclingResponse (
	cea2045::cea2045IntermediateResponse *message) {
	// do nothing
}  // end Process Start Cycling Response

// Process Terminate Cycling Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processTerminateCyclingResponse (
	cea2045::cea2045IntermediateResponse *message) {
	// do nothing
}  // end Process Terminate Cycling Response

// Process Get Present Temperature Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processGetPresentTemperatureResponse (
	cea2045::cea2045GetPresentTemperatureResponse *message) {
	// do nothing
}  // end Process Get Present Temperature Response

// Process Get UTC Time Response
// TODO(TS): this has not been implemented, but has been definded because it is 
// a pure virtual function of IUCM.
void UniversalControlModule::processGetUTCTimeResponse (
	cea2045::cea2045GetUTCTimeResponse *message) {
	// do nothing
}  // end Process Get UTC Time Response


// Process Ack Received
// - 
void UniversalControlModule::processAckReceived (
	cea2045::MessageCode messageCode) {
	// basically do nothing, but structure is there if logging or view Ack
	switch (messageCode) {
	case cea2045::MessageCode::SUPPORT_DATALINK_MESSAGES:
		break;

	case cea2045::MessageCode::SUPPORT_INTERMEDIATE_MESSAGES:
		break;

	default:
		break;
	}
}

// Process Nak Received
// - 
void UniversalControlModule::processNakReceived (
	cea2045::LinkLayerNakCode nak, cea2045::MessageCode messageCode) {
	std::cout << "[WARNING]: unsupported message type" << std::endl;
	if (nak == cea2045::LinkLayerNakCode::UNSUPPORTED_MESSAGE_TYPE) {
		switch (messageCode) {
		case cea2045::MessageCode::SUPPORT_DATALINK_MESSAGES:
			//Logger("WARNING") << "does not support data link";
			break;

		case cea2045::MessageCode::SUPPORT_INTERMEDIATE_MESSAGES:
			//Logger("WARNING") << "does not support intermediate";
			break;

		default:
			break;
		}
	}
}  // end Process Nak Received

// Process Operational State Received
// -
void UniversalControlModule::processOperationalStateReceived (
	cea2045::cea2045Basic *message) {
	op_state_ = (unsigned int)message->opCode1;

	// TODO(TS): this is just for debugging and should be removed later
	std::cout << "Operational State: " 
		<< "\tOpCode #1 = " << message->opCode1 
		<< "\tOpCode #2 = " << message->opCode2 << std::endl;
}  // end Process Operation State Received

// Process App Ack Received
// -
void UniversalControlModule::processAppAckReceived (
	cea2045::cea2045Basic* message) {
	// do nothing
}  // end Process App Ack Received

// Process App Nak Received
// - 
void UniversalControlModule::processAppNakReceived (
	cea2045::cea2045Basic* message) {
	// do nothing
}  // end PRocess App Nak Received

// Process App Cuxstomer Override
// -
void UniversalControlModule::processAppCustomerOverride (
	cea2045::cea2045Basic* message) {
	// TODO(TS): this may be required by the DCS so a member variable should be
	// created.
}  // end Process App Customer Override

// Process Incomplete Message
void UniversalControlModule::processIncompleteMessage (
	const unsigned char *buffer, unsigned int numBytes) {
	// do nothing
}
